 

# jvm面试提收集



## 1.Jvm对象何时会进入老年代？

#### 对象年龄:

对象年龄大于15时会进入老年代

![image-20220715013046676](./assets/image-20220715013046676.png)



#### 动态对象年龄判断:

以一部分对象确认一下年龄基线,大于这个基线的回收到老年代.如何确定?

![image-20220715013548834](assets/image-20220715013548834.png)

#### 大对象直接进入老年代:

![image-20220715013758287](assets/image-20220715013758287.png)

#### survivor区域对象空间不足:

![image-20220715013851393](assets/image-20220715013851393.png)



## 2.JVM什么情况下会触发FullGC？



#### system.gc():

![image-20220715014113547](assets/image-20220715014113547.png)

#### 老年代空间不足:

![image-20220715014224040](assets/image-20220715014224040.png)

#### cmsgc出现错误:



![image-20220715014450543](assets/image-20220715014450543.png)

#### minor gc晋升到老年代大于老年代剩余空间:



![image-20220715014656204](assets/image-20220715014656204.png)

#### 堆中分配很大的对象:

![image-20220715014745394](assets/image-20220715014745394.png)



## 3.jvm类加载机制

**过程题**

#### 加载

![image-20220715015241996](assets/image-20220715015241996.png)

#### 链接

##### 验证:验证字节码文件结构,语义检查.

![image-20220715015539566](assets/image-20220715015539566.png)

##### 准备:设置初始值

![image-20220715015708415](assets/image-20220715015708415.png)

##### 解析: 字符引用改为地址值

![image-20220715015719887](assets/image-20220715015719887.png)

#### 初始化:

![image-20220715015841370](assets/image-20220715015841370.png)

## 4.jvm调优最佳参数



![image-20220715020125167](assets/image-20220715020125167.png)

![image-20220715020158656](assets/image-20220715020158656.png)

![image-20220715020450752](assets/image-20220715020450752.png)



#### 原则1:堆,栈,初始和最大内存设置的要相等,避免后续申请内存,造成内存抖动.元空间根据需求来设置.

![image-20220715020716539](assets/image-20220715020716539.png)

#### 原则2:并行相关可以设置并行数.当cpu小于8时设置和cpu相等,当大于8时根据公式得出.



![image-20220715021007866](assets/image-20220715021007866.png)

#### 原则3:老年代开启压缩整理,配置压缩整理的频率. 配置老年代gc的阈值.



![image-20220715021620979](assets/image-20220715021620979.png)

#### 原则4:cms开启system.gc()并行gc,开启并行标记. 开启开快速抛出异常,jvm检测到多次抛出一个异常,会直接抛出而不需要在堆中创建内存.





## 5. 三色标记法

#### 可达性:

![image-20220724234007134](assets/image-20220724234007134.png)

#### 三色的判别:

初始标记

![image-20220724234121514](assets/image-20220724234121514.png)

并发标记

![image-20220724234248136](assets/image-20220724234248136.png)

重复并发标记

![image-20220724234316306](assets/image-20220724234316306.png)

#### 缺点:

多标

![image-20220724234617799](assets/image-20220724234617799.png)

浮动垃圾不会影响程序正确性.

漏标:

![image-20220724234850002](assets/image-20220724234850002.png)



#### 解决办法:



![image-20220724235147303](assets/image-20220724235147303.png)



![image-20220724235316669](assets/image-20220724235316669.png)

## 6.垃圾回收算法有哪些

#### 标记清除算法

![image-20220724235712316](assets/image-20220724235712316.png)

#### 标记整理

![image-20220724235800177](assets/image-20220724235800177.png)

#### 复制算法

![image-20220724235845054](assets/image-20220724235845054.png)

#### 分代算法

![image-20220724235925712](assets/image-20220724235925712.png)
